# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1rfJYi2mT7xyZU9Cj-2iCiTJAG9GYi0JC
"""

#pip install jiagu
#pip install jieba

# Import jieba and jiagu for Chinese text segmentation
import jieba
import jiagu


class Segment:
    def jieba_seg(self, text):
        # Segment text using jieba
        return list(jieba.cut(text))

    def jiagu_seg(self, text):
        # Segment text using jiagu
        return jiagu.seg(text)

class Report:
    def compare_line(self, reference, candidate):
        # Split the reference and candidate sentences into words
        ref_words = reference.split()
        can_words = candidate.split()

        # Calculate the length of the reference and candidate word lists
        ref_words_len = len(ref_words)
        can_words_len = len(can_words)

        # Calculate the number of accurately segmented words
        # by finding the intersection of reference and candidate words
        acc_word_len = len(set(ref_words) & set(can_words))

        # Return the length of reference words, candidate words, and accurately segmented words
        return ref_words_len, can_words_len, acc_word_len

import os
import time

def seg_test(seg, name, test_set):
    start = time.time()  # Start timing
    # Open the input file for reading and the output file for writing segmented text
    fin = open(f'{test_set}.txt', 'r', encoding='utf8')
    fout = open(f'result/{test_set}.{name}', 'w', encoding='utf8')
    for line in fin:
        line = line.strip()  # Remove leading and trailing whitespaces
        if line == '':
            fout.write('\n')  # Write an empty line if the line is empty
        else:
            # Get the segmentation method from the Segment class based on the 'name' argument
            # and segment the line
            words = getattr(seg, f'{name}_seg')(line)
            fout.write(' '.join(words) + '\n')  # Write the segmented words to the output file
    fin.close()  # Close the input file
    fout.close()  # Close the output file
    print(f'{name} time: {time.time() - start}')  # Print the time taken for segmentation

def test_value(name, test_set):
    report = Report()  # Initialize the Report class
    # Open the reference file and the candidate file for evaluation
    fref = open(f'{test_set}.txt', 'r', encoding='utf8')
    fcan = open(f'result/{test_set}.{name}', 'r', encoding='utf8')
    # Read all lines from both files
    reference_all = fref.readlines()
    candidate_all = fcan.readlines()
    ref_count, can_count, acc_count = 0, 0, 0  # Initialize counters
    for reference, candidate in zip(reference_all, candidate_all):
        # Compare each line from the reference and candidate files
        ref_len, can_len, acc_len = report.compare_line(reference.strip(), candidate.strip())
        # Accumulate the total length of reference words, candidate words, and accurately segmented words
        ref_count += ref_len
        can_count += can_len
        acc_count += acc_len
    # Calculate Precision, Recall, and F1 score
    P, R = acc_count / can_count * 100, acc_count / ref_count * 100
    F1 = 2 * P * R / (P + R) if (P + R) > 0 else 0
    # Print the accuracy, recall, and F1 score
    print(f'{name}\nAccuracy: {P}\nRecall: {R}\nF1: {F1}\n')

!mkdir -p result  # Create a directory to store the results

seg = Segment()  # Initialize the segmentation class
tools = ['jieba', 'jiagu']  # Use 'jiagu' and 'jiagu'
test_sets = ['test_msr', 'test_pku']

# Iterate through each test set
for test_set in test_sets:
    print(f'{test_set} test...')  # Print the current test set being processed
    # Iterate through each tool and apply segmentation on the test set
    for tool in tools:
        seg_test(seg, tool, test_set)  # Perform segmentation

    print('-----------------------------------')  # Separator for readability
    # After segmentation, evaluate and print the performance values for each tool
    print(f'{test_set} value...')
    for tool in tools:
        test_value(tool, test_set)  # Evaluate segmentation performance
    print('===================================')  # End of the test set evaluation